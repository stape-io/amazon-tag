___TERMS_OF_SERVICE___

By creating or modifying this file you agree to Google Tag Manager's Community
Template Gallery Developer Terms of Service available at
https://developers.google.com/tag-manager/gallery-tos (or such other URL as
Google may provide), as modified from time to time.


___INFO___

{
  "type": "TAG",
  "id": "cvt_temp_public_id",
  "version": 1,
  "securityGroups": [],
  "displayName": "Amazon CAPI",
  "categories": [
    "ADVERTISING",
    "ANALYTICS",
    "CONVERSIONS",
    "MARKETING",
    "REMARKETING"
  ],
  "brand": {
    "id": "brand_dummy",
    "displayName": "",
    "thumbnail": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEmCAMAAADvOF0hAAAAAXNSR0IB2cksfwAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAACdQTFRFAAAA9KlD7aZG4aFK3Z9LSkQ8PDcxMTExKysrJSUlHh4eGhoa+6xBly/orwAAAAF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH6QYFDBkiAnv04AAACMdJREFUeNrtndu6oyAMhSVXCfj+z7tb292zyjEkAeZuZr6qv2uFgyEsS/eGWyPyj0Z0+ztcZnvhRHdG4av9Y6NJbPmXUjhrl//iaVyRXTjFUPpkNqDGrqBCbrtKbJKaAvsiFeq0CzCcpFJ4oWX7hcrtIq9JKi3cT1TD4mqJ6oZrohoPFzKg2nChgWAVuJp6cZEPjE23uHhZqRYXMqPSTIv4Wam1Yh9WKmkx9oLqaaEPYdJSwEoZrc6sVNHqzioEmqzs0RLBSosRKYRJSxcrFUYkLwWWfGmhGFYKaAliJd6IJImVcGmhKGEJl5YwVsFPE5qQljQTipaWPGGFgFNY+n1YR1j3rG7jPiwX1j3xfdlS4onqEEOLwvqRVIs18pTQnLD2E6yKeXljwjrORSu0t0hYjVAVr/pInB9iy4cpEhfZcSG1N7mVKXR8zos3BIuaxxNvJ2hR88fIj1towYWJrxytRPis146y+hDRLkx+BjQCy7PEXW+iO8xxITGZXR4spicwAYuY+nOyMNDyTG8bx4RFbLFR3KjUc73sMWFxTteF2ZC4xolkQFmpsST7XVuAdaHlWUY+JmAlrpNnz9bQBqyttlNccaeCiGsF1oMZnpbEyl8GMAYrQmlUEhttwtoTWtG+XNuw3rFRaem+UWD1W76esCasCWvCmrAmrAlrwpqwJqwJqxesMGG1FdZYsG4z8PwtF2gf0MsRDaEsFR4NM4penh4X1h3SSHsOM9VUWUomYd0whdbNACwWThZgXeJT4NskjLpB8Tac3jMOC7ugUgmrX5VXdbD6aEojLOyJShcs7F3ZTlOB1+5VV3CqyhoslFFaEnX0gCFMWFqClRpYcoq7ioclqvAYTlZWYJGsgnaiYUkrlIiTlQVYAmtK4mSlH5bIWqU4Div/X7rUG0sMqcnqCmdLnsFHTU4kQ7CoGqYroR/PaCiZrQarrQhuZZtLhEU16gVjg5iIBoN7xDnjZmAVFqqN2jhtBVaZCSP3mBuBVViHuulV0JAJffxWYBuwiEFWVmAVmJChsitaERYxvBQ0IixahoNFTKwswMoWll/Gg0Ucsd0KLM/FygAsxmra+mEx1odWv/iHjCvj6pVFfMLSryzPFd0NKIu1SLt2ZRFbV7jor1PK6ULtsHiPStAOi9OF2mFR4Lx/5bBYQ5by4vnMp7sMCYtYr4ZDxncMqmHRhCUVFu/VpKxlkYar6R45oPJj6FhTYrM/jKjuDDNhBeWwOJWV/3kSx1NW9ndvKbAY+6eCTB1Sraycuyfth5RzKqsktxAHU1bRjgTVsDxnxJIStJAtJ6Rsq4tXrSxkjFhSfIhcvijdQ0WKbZjqi/J9QagZFrIKS0TUYkpTrrCRUYK0WN50lZ3XAqTFMl+rs5u4v7SIwRe1dl6jXljR0qpWrYUUw4p80/Uq23SXFrYOuTWrAPWmhY19UbdiUmcjtl0MqF67ujMt3/DmGxR4I60R/iSMNCmY1DdsYend054D2xSX6kurvKbK9+Z7bFgQlhT7cMP1xut6Qlho2EixD/95hf+T5lrXdutpRJGF68RKSx2sntKiCWv6cEqrPyw/bWg2xPddjccpLKPSUr1eOhorbmn5/Nmj6s/4uQ+MXi0r1rHW7YGzaCnfxJMvDtLLis2IDyMlX9CLYcU1jn9ZJUyk5U3UZ8s2UtLr8VZKSuYayatl1Z7W1wPHX5AWca0trR/iQH2hnWfa89NIUWFLJquG2tp7YFIYrlrT2heH18uKP0Ph7Hpe9Hl99Y+4P445h7SkhqtmY/kzbRzQks+qrhUjnnf3cl7Hadu1xBV3vMUOLa/mGHfPhmrvan7R0zgOeDq6GC2qWlFGWgqqH31wkQXh1tzlz72JxpWI6mssn8sK3LWtn82tzjEQQ0rm5TNIfXQqOawArkzW/Xb5V1G8bqdAluo4Y3QF7gjTCzAGQ17TRP05pwJQz+tQsi5jSbHhumYgbwmjH8z8jRIh9hoUQQKpjRZjD/nduvbYsCY3t4zZMlBxGVEcKrdmtRGl5TJZDQgrV1bXBs+R/mQVBev+CwNEMFjXQlgwTsB3pbDelGkbV5mwrrDcOMMJVwoLBuoii2G5gcaqawNYZnG5JrCM4oL6MetOyyIu93sldGv3BXi3Ox1ycKRNg7jcG6KdjxI7w3x3MgOwh+sqndPPELA/kYbDRZwRV3EOYB3PLp2bsN4WHY7n4uPhguPlLDdXVONhna0fjoXrDNbpgG0kM7qjddK4RcRx1HUOK2LJ1SCun0OjqM8V5xNNW7i2D/jf8zqIghUzLTeDC3aX0+HchZFWNILrIyvEJbswlpb+nvFwefgnArdk01I9Z/yZavRil1gXJqwnKl3vAjj9OB8vrJQFRX24DvLX3KG14Og3LeLaskfP0z6SXJhgRUVuhNPpXJ4L02ipwBVhlUNYUP77StwYl2jrDlzoarwNBfKKTkmGAmGlWVGovBLe95ELXe2LyZNXUpr7M6svU1hLRqKcEF7gcl2RLax0K4qwIySn2D5vuUBYWeLqKi8AV/R6i4S15OasdgCWBerDCa44Wy0z+YSTF+Rnt8Pxk0L6raxyeQHkk/oUTrmwCsR1BwYtnVeSofb5Ll2dlNGibPsWwIr0tIMCyk1Yg9Zt92wdYlCD088xTi1WFXA9NAbZkApddzIc/HrAok8NlW70nnWX1NfVo7Q/dIa6Oe5Q8Y7dvRIAfBRRePmbW5reWhfT/iwDau8HcPXv/I3e2u73zydkrvbeCWB4msasosJMpREi6EYFUUG52mhar7hOZxSuwdZLpbgiGGwdb+0BtHMWUcmb5w+HSpsXBax2a8El5EMKaCAl55uTcFzS8u5g+k8/LrkpBVNUanHJT4OSMpBQkl8nAZeizM3OkyB1Gee9eLlVZ25+B1yay1CwysvprxHAw0ur+fh5WSsBc7ytoTAbYDHYKgNz5uuYVHKkG6bgS1Feh7PQ6aUTS0L2KN20DNzgLDPmVgNsbEjfOntWRHvWRxMqpT8xl7LNnHts/gAAAABJRU5ErkJggg\u003d\u003d"
  },
  "description": "Amazon Ads server-to-server conversion tracking.",
  "containerContexts": [
    "SERVER"
  ]
}


___TEMPLATE_PARAMETERS___

[
  {
    "type": "RADIO",
    "name": "eventType",
    "displayName": "Event Name Setup Method",
    "radioItems": [
      {
        "value": "standard",
        "displayValue": "Standard",
        "subParams": [
          {
            "type": "SELECT",
            "name": "eventNameStandard",
            "selectItems": [
              {
                "displayValue": "AddToShoppingCart",
                "value": "AddToShoppingCart"
              },
              {
                "displayValue": "Contact",
                "value": "Contact"
              },
              {
                "displayValue": "Checkout",
                "value": "Checkout"
              },
              {
                "displayValue": "PageView",
                "value": "PageView"
              },
              {
                "displayValue": "Search",
                "value": "Search"
              },
              {
                "displayValue": "Signup",
                "value": "Signup"
              },
              {
                "displayValue": "Application",
                "value": "Application"
              },
              {
                "displayValue": "Subscribe",
                "value": "Subscribe"
              },
              {
                "value": "Other",
                "displayValue": "Other"
              },
              {
                "value": "Lead",
                "displayValue": "Lead"
              },
              {
                "value": "Off-AmazonPurchases",
                "displayValue": "Off-AmazonPurchases"
              }
            ],
            "simpleValueType": true,
            "defaultValue": "PageView",
            "displayName": "Event Name",
            "valueValidators": [
              {
                "type": "NON_EMPTY"
              }
            ],
            "alwaysInSummary": true
          }
        ],
        "help": ""
      },
      {
        "value": "inherit",
        "subParams": [],
        "displayValue": "Inherit from client",
        "help": "This option uses the event name from the incoming request.\n\u003cbr/\u003e\u003cbr/\u003e\nIf the incoming request uses the \u003cb\u003eGoogle Analytics 4 (GA4)\u003c/b\u003e event naming schema, the following mappings will be applied to convert GA4 event names into Amazon equivalents: \n\u003cbr/\u003e \n\u003cul\u003e \n\u003cli\u003epage_view → PageView\u003c/li\u003e \u003cli\u003egtm.dom → PageView\u003c/li\u003e \u003cli\u003esign_up → Signup\u003c/li\u003e \u003cli\u003egenerate_lead → Lead\u003c/li\u003e \u003cli\u003esearch → Search\u003c/li\u003e \u003cli\u003eview_search_results → Search\u003c/li\u003e \u003cli\u003eadd_to_cart → AddToShoppingCart\u003c/li\u003e \u003cli\u003ebegin_checkout → Checkout\u003c/li\u003e \u003cli\u003epurchase → AmazonPurchases\u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "value": "custom",
        "subParams": [
          {
            "type": "TEXT",
            "name": "eventNameCustom",
            "displayName": "Event Name",
            "simpleValueType": true,
            "valueValidators": [
              {
                "type": "NON_EMPTY"
              }
            ]
          }
        ],
        "displayValue": "Custom",
        "help": ""
      }
    ],
    "simpleValueType": true,
    "defaultValue": "standard"
  },
  {
    "type": "SIMPLE_TABLE",
    "name": "tagIdsList",
    "simpleTableColumns": [
      {
        "defaultValue": "",
        "displayName": "",
        "name": "value",
        "type": "TEXT",
        "isUnique": true,
        "valueValidators": [
          {
            "type": "NON_EMPTY"
          }
        ],
        "valueHint": "2a2b1197-3668-554f-be9ca-9baaaa88a7c9"
      }
    ],
    "valueValidators": [
      {
        "type": "NON_EMPTY"
      }
    ],
    "newRowButtonText": "Add Tag ID",
    "help": "You can find your ID by clicking on \u003ci\u003eView Tag Code\u003c/i\u003e in the Events Manager section in Amazon DSP. \u003ca href\u003d\"https://advertising.amazon.com/help/GLZ54GXQW773A6MG\"\u003eLearn more\u003c/a\u003e.",
    "displayName": "Tag ID(s)"
  },
  {
    "type": "SELECT",
    "name": "tagRegion",
    "displayName": "Region",
    "selectItems": [
      {
        "value": "NA",
        "displayValue": "North America, South America, Japan and Australia"
      },
      {
        "value": "EU",
        "displayValue": "Europe"
      }
    ],
    "simpleValueType": true,
    "defaultValue": "NA"
  },
  {
    "type": "SELECT",
    "name": "overrideCookieSettings",
    "displayName": "Override cookie settings",
    "macrosInSelect": true,
    "selectItems": [
      {
        "value": false,
        "displayValue": "false"
      },
      {
        "value": true,
        "displayValue": "true"
      }
    ],
    "simpleValueType": true,
    "defaultValue": false,
    "subParams": [
      {
        "type": "GROUP",
        "name": "cookieSettingsGroup",
        "displayName": "Cookie Settings",
        "groupStyle": "ZIPPY_OPEN",
        "subParams": [
          {
            "type": "TEXT",
            "name": "cookieDomain",
            "displayName": "Cookie Domain",
            "simpleValueType": true,
            "defaultValue": "auto",
            "valueHint": "example.com",
            "help": "Enable this option to override the cookie domain. \u003cbr\u003e Enter your website\u0027s top-level domain as a fixed value (e.g., example.com). \u003cbr\u003e If left unchecked, the top-level domain will be automatically determined using the following priority: \u003cul\u003e \u003cli\u003eTop-level domain of the \u003ci\u003eForwarded\u003c/i\u003e header (if present).\u003c/li\u003e \u003cli\u003eTop-level domain of the \u003ci\u003eX-Forwarded-Host\u003c/i\u003e header (if present).\u003c/li\u003e \u003cli\u003eTop-level domain of the \u003ci\u003eHost\u003c/i\u003e header.\u003c/li\u003e \u003c/ul\u003e"
          },
          {
            "type": "SELECT",
            "name": "cookieHttpOnly",
            "displayName": "Cookie HTTP Only Flag",
            "macrosInSelect": true,
            "selectItems": [
              {
                "value": true,
                "displayValue": "true"
              },
              {
                "value": false,
                "displayValue": "false"
              }
            ],
            "simpleValueType": true,
            "defaultValue": true
          }
        ],
        "enablingConditions": [
          {
            "paramName": "overrideCookieSettings",
            "paramValue": false,
            "type": "NOT_EQUALS"
          }
        ]
      }
    ]
  },
  {
    "type": "SELECT",
    "name": "notSetMeasurementTokenCookie",
    "displayName": "Do not set the Measurement Token cookie (amznAref)",
    "macrosInSelect": true,
    "selectItems": [
      {
        "value": false,
        "displayValue": "false"
      },
      {
        "value": true,
        "displayValue": "true"
      }
    ],
    "simpleValueType": true,
    "help": "Do not set Measurement Token (\u003ci\u003eamznAref\u003c/i\u003e) cookie. \n\u003cbr\u003e\u003cbr\u003e\nIf an existing Measurement Token cookie is found, it will still be sent in the request but not stored as a cookie. (Only applicable to the \u003ci\u003eNorth America, South America, Japan and Australia\u003c/i\u003e region. For \u003ci\u003eEurope\u003c/i\u003e, the Measurement Token is never transmitted.).",
    "defaultValue": false
  },
  {
    "type": "SELECT",
    "name": "useOptimisticScenario",
    "displayName": "Use Optimistic Scenario",
    "macrosInSelect": true,
    "selectItems": [
      {
        "value": true,
        "displayValue": "true"
      },
      {
        "value": false,
        "displayValue": "false"
      }
    ],
    "simpleValueType": true,
    "help": "The tag will call gtmOnSuccess() without waiting for a response from the API. This will speed up sGTM response time however your tag will always return the status fired successfully even in case it is not.",
    "defaultValue": false
  },
  {
    "type": "GROUP",
    "name": "userDataAttributesGroup",
    "displayName": "User Data Attributes",
    "groupStyle": "ZIPPY_OPEN_ON_PARAM",
    "subParams": [
      {
        "type": "TEXT",
        "name": "matchId",
        "displayName": "Match ID",
        "simpleValueType": true,
        "help": "The Match ID enables mapping of ID-less events to ID-have events via a user-unique value (such as a User ID). This feature is especially helpful when an advertiser only obtains user information part of the way through their flow.\n\u003cbr\u003e\u003cbr\u003e\n\u003ca href\u003d\"https://advertising.amazon.com/help/GY9FGKVE76CYWQ29\"\u003eLearn more\u003c/a\u003e.\n\u003cbr\u003e\u003cbr\u003e\nDefault: \u003ci\u003eeventData.user_id\u003c/i\u003e."
      },
      {
        "type": "CHECKBOX",
        "name": "enableAdvancedMatching",
        "checkboxText": "Enable Advanced Matching",
        "simpleValueType": true,
        "help": "Enables capturing email address and/or phone number as an alternative ad-identifier to the standard browser cookie.\nIt stores a 1st party cookie named \u003ci\u003eaatToken\u003c/i\u003e on the user’s browser that is sent in all the events."
      },
      {
        "type": "GROUP",
        "name": "advancedMatchingGroup",
        "displayName": "Advanced Matching Attributes",
        "groupStyle": "ZIPPY_OPEN",
        "subParams": [
          {
            "type": "LABEL",
            "name": "userDataAttributesListLabel",
            "displayName": "If not set, email address and phone number will attempt to be inherited automatically from \u003ci\u003eeventData\u003c/i\u003e."
          },
          {
            "type": "SIMPLE_TABLE",
            "name": "userDataAttributesList",
            "simpleTableColumns": [
              {
                "defaultValue": "",
                "displayName": "Attribute Name",
                "name": "name",
                "type": "SELECT",
                "isUnique": true,
                "valueValidators": [
                  {
                    "type": "NON_EMPTY"
                  }
                ],
                "selectItems": [
                  {
                    "value": "email",
                    "displayValue": "Email (if not SHA256 hashed, it will be automatically hashed)"
                  },
                  {
                    "value": "phonenumber",
                    "displayValue": "Phone Number (if not SHA256 hashed, it will be automatically hashed)"
                  }
                ]
              },
              {
                "defaultValue": "",
                "displayName": "Attribute Value",
                "name": "value",
                "type": "TEXT"
              }
            ],
            "newRowButtonText": "Add Attribute"
          },
          {
            "type": "TEXT",
            "name": "aipTokenCookieTTL",
            "displayName": "Advanced Matching Cookie Expiration Time",
            "simpleValueType": true,
            "valueHint": "9600",
            "valueUnit": "seconds",
            "help": "The Advanced Matching (\u003ci\u003eaatToken\u003c/i\u003e) cookie lifetime. This controls when the cookie will be refreshed.\nIt should not exceed 7 days (604800 seconds).",
            "defaultValue": 9600
          },
          {
            "type": "GROUP",
            "name": "amazonConsentGroup",
            "displayName": "Amazon Consent",
            "groupStyle": "NO_ZIPPY",
            "subParams": [
              {
                "type": "TEXT",
                "name": "ipAddress",
                "displayName": "IP Address",
                "simpleValueType": true,
                "help": "Default: \u003ci\u003eeventData.ip_override\u003c/i\u003e."
              },
              {
                "type": "TEXT",
                "name": "countryCode",
                "displayName": "Country Code",
                "simpleValueType": true,
                "help": "The country where the event originates from. e.g. US \n\u003cbr\u003e\nThis value must be in \u003ca href\u003d\"https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\"\u003eISO 3166-1 alpha-2\u003c/a\u003e format.",
                "valueValidators": [
                  {
                    "type": "NON_EMPTY"
                  },
                  {
                    "type": "STRING_LENGTH",
                    "args": [
                      2,
                      2
                    ]
                  }
                ]
              },
              {
                "type": "TEXT",
                "name": "gpp",
                "displayName": "Global Privacy Platform string",
                "simpleValueType": true,
                "valueHint": "DBABjw~1YNN~CPXxRfAPXxRfAAfKABENB-CgAAAAAAAAAAYgAAAAAAAA"
              },
              {
                "type": "TEXT",
                "name": "amznAdStorage",
                "displayName": "Amazon Ad Storage (GRANTED or DENIED)",
                "simpleValueType": true,
                "help": "If the \u003cb\u003eGlobal Privacy Platform string\u003c/b\u003e and the \u003cb\u003eAmazon User Data\u003c/b\u003e are not set, this field will be set as \u003cI\u003eGRANTED\u003c/I\u003e."
              },
              {
                "type": "TEXT",
                "name": "amznUserData",
                "displayName": "Amazon User Data (GRANTED or DENIED)",
                "simpleValueType": true,
                "help": "If the \u003cb\u003eGlobal Privacy Platform string\u003c/b\u003e and the \u003cb\u003eAmazon Ad Storage\u003c/b\u003e are not set, this field will be set as \u003cI\u003eGRANTED\u003c/I\u003e."
              }
            ]
          }
        ],
        "enablingConditions": [
          {
            "paramName": "enableAdvancedMatching",
            "paramValue": true,
            "type": "EQUALS"
          }
        ]
      }
    ]
  },
  {
    "type": "GROUP",
    "name": "tcfv2Group",
    "displayName": "TCFv2 Information",
    "groupStyle": "ZIPPY_OPEN_ON_PARAM",
    "subParams": [
      {
        "type": "CHECKBOX",
        "name": "includeTCFv2",
        "checkboxText": "Include TCFv2 Information",
        "simpleValueType": true,
        "subParams": [
          {
            "type": "GROUP",
            "name": "tcfv2AttributesGroup",
            "displayName": "",
            "groupStyle": "NO_ZIPPY",
            "subParams": [
              {
                "type": "SELECT",
                "name": "gdpr",
                "displayName": "GDPR consent",
                "selectItems": [
                  {
                    "value": 0,
                    "displayValue": "GDPR does not apply (0)"
                  },
                  {
                    "value": 1,
                    "displayValue": "GDPR applies (1)"
                  }
                ],
                "simpleValueType": true,
                "macrosInSelect": true,
                "help": "If using a variable, it should return:\n\u003cul\u003e\n\u003cli\u003eThe number \u003cb\u003e0\u003c/b\u003e: GDPR does not apply\u003c/li\u003e\n\u003cli\u003eThe number \u003cb\u003e1\u003c/b\u003e: GDPR applies\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eundefined\u003c/b\u003e: GDPR unknown\u003c/li\u003e\n\u003c/ul\u003e",
                "notSetText": "GDPR unknown"
              },
              {
                "type": "SELECT",
                "name": "gdprPd",
                "displayName": "GDPR personal data",
                "macrosInSelect": true,
                "selectItems": [
                  {
                    "value": 0,
                    "displayValue": "Does not contain personal data (0)"
                  },
                  {
                    "value": 1,
                    "displayValue": "Contains personal data (1)"
                  }
                ],
                "simpleValueType": true,
                "help": "If using a variable, it should return: \n\u003cul\u003e \n\u003cli\u003eThe number \u003cb\u003e0\u003c/b\u003e: Does not contain personal data\u003c/li\u003e\n\u003cli\u003eThe number \u003cb\u003e1\u003c/b\u003e: Contains personal data\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eundefined\u003c/b\u003e: unknown\u003c/li\u003e\n\u003c/ul\u003e",
                "notSetText": "Unknown"
              },
              {
                "type": "TEXT",
                "name": "gdprTCFConsentString",
                "displayName": "TCFv2 consent string",
                "simpleValueType": true,
                "valueHint": "CPXxRfAPXxRfAAfKABENB-CgAAAAAAAAAAYgAAAAAAAA"
              }
            ],
            "enablingConditions": [
              {
                "paramName": "includeTCFv2",
                "paramValue": true,
                "type": "EQUALS"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "GROUP",
    "name": "eventAttributesGroup",
    "displayName": "Event Attributes",
    "groupStyle": "ZIPPY_OPEN_ON_PARAM",
    "subParams": [
      {
        "type": "GROUP",
        "name": "defaultAttributesGroup",
        "displayName": "Event attributes for all events",
        "groupStyle": "NO_ZIPPY",
        "subParams": [
          {
            "type": "SIMPLE_TABLE",
            "name": "defaultAttributesList",
            "simpleTableColumns": [
              {
                "defaultValue": "",
                "displayName": "Attribute Name",
                "name": "name",
                "type": "SELECT",
                "selectItems": [
                  {
                    "value": "value",
                    "displayValue": "value"
                  },
                  {
                    "value": "brand",
                    "displayValue": "brand"
                  },
                  {
                    "value": "category",
                    "displayValue": "category"
                  },
                  {
                    "value": "productId",
                    "displayValue": "productId"
                  },
                  {
                    "value": "attr1",
                    "displayValue": "attr1"
                  },
                  {
                    "value": "attr2",
                    "displayValue": "attr2"
                  },
                  {
                    "value": "attr3",
                    "displayValue": "attr3"
                  },
                  {
                    "value": "attr4",
                    "displayValue": "attr4"
                  },
                  {
                    "value": "attr5",
                    "displayValue": "attr5"
                  },
                  {
                    "value": "attr6",
                    "displayValue": "attr6"
                  },
                  {
                    "value": "attr7",
                    "displayValue": "attr7"
                  },
                  {
                    "value": "attr8",
                    "displayValue": "attr8"
                  },
                  {
                    "value": "attr9",
                    "displayValue": "attr9"
                  },
                  {
                    "value": "attr10",
                    "displayValue": "attr10"
                  }
                ],
                "isUnique": true,
                "valueValidators": [
                  {
                    "type": "NON_EMPTY"
                  }
                ]
              },
              {
                "defaultValue": "",
                "displayName": "Attribute Value",
                "name": "value",
                "type": "TEXT",
                "isUnique": false,
                "valueValidators": []
              }
            ],
            "newRowButtonText": "Add Attribute"
          }
        ]
      },
      {
        "type": "GROUP",
        "name": "offAmazonPurchasesAttributesGroup",
        "displayName": "Event attributes for the \"Off-AmazonPurchases\" event only",
        "groupStyle": "NO_ZIPPY",
        "subParams": [
          {
            "type": "SIMPLE_TABLE",
            "name": "offAmazonPurchasesAttributesList",
            "simpleTableColumns": [
              {
                "defaultValue": "",
                "displayName": "Attribute Name",
                "name": "name",
                "type": "SELECT",
                "selectItems": [
                  {
                    "value": "currencyCode",
                    "displayValue": "currencyCode"
                  },
                  {
                    "value": "unitsSold",
                    "displayValue": "unitsSold"
                  }
                ],
                "valueValidators": [
                  {
                    "type": "NON_EMPTY"
                  }
                ],
                "isUnique": true
              },
              {
                "defaultValue": "",
                "displayName": "Attribute Value",
                "name": "value",
                "type": "TEXT"
              }
            ],
            "newRowButtonText": "Add Attribute",
            "displayName": "\"Off-Amazon Purchases\" Event Attributes"
          }
        ]
      }
    ]
  },
  {
    "type": "GROUP",
    "name": "eventCustomAttributesGroup",
    "displayName": "Event Custom Attributes",
    "groupStyle": "ZIPPY_OPEN_ON_PARAM",
    "subParams": [
      {
        "type": "SIMPLE_TABLE",
        "name": "eventCustomAttributesList",
        "simpleTableColumns": [
          {
            "defaultValue": "",
            "displayName": "Attribute Name",
            "name": "name",
            "type": "TEXT",
            "valueValidators": [
              {
                "type": "NON_EMPTY"
              }
            ],
            "isUnique": true
          },
          {
            "defaultValue": "",
            "displayName": "Attribute Value",
            "name": "value",
            "type": "TEXT"
          }
        ],
        "newRowButtonText": "Add Attribute"
      }
    ]
  },
  {
    "type": "GROUP",
    "name": "consentSettingsGroup",
    "displayName": "Consent Settings",
    "groupStyle": "ZIPPY_CLOSED",
    "subParams": [
      {
        "type": "RADIO",
        "name": "adStorageConsent",
        "displayName": "",
        "radioItems": [
          {
            "value": "optional",
            "displayValue": "Send data always"
          },
          {
            "value": "required",
            "displayValue": "Send data in case marketing consent given"
          }
        ],
        "simpleValueType": true,
        "defaultValue": "optional"
      }
    ]
  },
  {
    "displayName": "Logs Settings",
    "name": "logsGroup",
    "groupStyle": "ZIPPY_CLOSED",
    "type": "GROUP",
    "subParams": [
      {
        "type": "RADIO",
        "name": "logType",
        "radioItems": [
          {
            "value": "no",
            "displayValue": "Do not log"
          },
          {
            "value": "debug",
            "displayValue": "Log to console during debug and preview"
          },
          {
            "value": "always",
            "displayValue": "Always log to console"
          }
        ],
        "simpleValueType": true,
        "defaultValue": "debug"
      }
    ]
  },
  {
    "displayName": "BigQuery Logs Settings",
    "name": "bigQueryLogsGroup",
    "groupStyle": "ZIPPY_CLOSED",
    "type": "GROUP",
    "subParams": [
      {
        "type": "RADIO",
        "name": "bigQueryLogType",
        "radioItems": [
          {
            "value": "no",
            "displayValue": "Do not log to BigQuery"
          },
          {
            "value": "always",
            "displayValue": "Log to BigQuery"
          }
        ],
        "simpleValueType": true,
        "defaultValue": "no"
      },
      {
        "type": "GROUP",
        "name": "logsBigQueryConfigGroup",
        "groupStyle": "NO_ZIPPY",
        "subParams": [
          {
            "type": "TEXT",
            "name": "logBigQueryProjectId",
            "displayName": "BigQuery Project ID",
            "simpleValueType": true,
            "help": "Optional.  \u003cbr\u003e\u003cbr\u003e  If omitted, it will be retrieved from the environment variable \u003cI\u003eGOOGLE_CLOUD_PROJECT\u003c/i\u003e where the server container is running. If the server container is running on Google Cloud, \u003cI\u003eGOOGLE_CLOUD_PROJECT\u003c/i\u003e will already be set to the Google Cloud project\u0027s ID."
          },
          {
            "type": "TEXT",
            "name": "logBigQueryDatasetId",
            "displayName": "BigQuery Dataset ID",
            "simpleValueType": true,
            "valueValidators": [
              {
                "type": "NON_EMPTY"
              }
            ]
          },
          {
            "type": "TEXT",
            "name": "logBigQueryTableId",
            "displayName": "BigQuery Table ID",
            "simpleValueType": true,
            "valueValidators": [
              {
                "type": "NON_EMPTY"
              }
            ]
          }
        ],
        "enablingConditions": [
          {
            "paramName": "bigQueryLogType",
            "paramValue": "always",
            "type": "EQUALS"
          }
        ]
      }
    ]
  }
]


___SANDBOXED_JS_FOR_SERVER___

const BigQuery = require('BigQuery');
const encodeUriComponent = require('encodeUriComponent');
const getAllEventData = require('getAllEventData');
const getContainerVersion = require('getContainerVersion');
const getCookieValues = require('getCookieValues');
const getRequestHeader = require('getRequestHeader');
const getTimestampMillis = require('getTimestampMillis');
const getType = require('getType');
const JSON = require('JSON');
const logToConsole = require('logToConsole');
const makeInteger = require('makeInteger');
const makeString = require('makeString');
const Object = require('Object');
const parseUrl = require('parseUrl');
const Promise = require('Promise');
const sendHttpGet = require('sendHttpGet');
const sendHttpRequest = require('sendHttpRequest');
const sendPixelFromBrowser = require('sendPixelFromBrowser');
const setCookie = require('setCookie');
const sha256Sync = require('sha256Sync');

/*==============================================================================
==============================================================================*/

const traceId = getRequestHeader('trace-id');

const eventData = getAllEventData();

const useOptimisticScenario = isUIFieldTrue(data.useOptimisticScenario);

if (!isConsentGivenOrNotRequired()) {
  return data.gtmOnSuccess();
}

const url = eventData.page_location || getRequestHeader('referer');
if (url && url.lastIndexOf('https://gtm-msr.appspot.com/', 0) === 0) {
  return data.gtmOnSuccess();
}

fetchAIPToken(data, eventData).then((aipToken) => {
  sendEventRequests(data, eventData, aipToken);
});

if (useOptimisticScenario) {
  return data.gtmOnSuccess();
}

/*==============================================================================
  Vendor related functions
==============================================================================*/

function mapEvent(data, eventData) {
  let mappedData = {
    event: mapEventName(data, eventData),
    eventSource: 'gtm-server-side',
    ts: getTimestampMillis()
  };

  mappedData = addGDPRData(data, mappedData);
  mappedData = addMeasurementToken(data, mappedData);
  mappedData = addEventDetailsData(data, eventData, mappedData);

  return mappedData;
}

function mapEventName(data, eventData) {
  if (data.eventType === 'inherit') {
    const eventName = eventData.event_name;

    const gaToEventName = {
      page_view: 'PageView',
      'gtm.dom': 'PageView',
      sign_up: 'Signup',
      generate_lead: 'Lead',
      search: 'Search',
      view_search_results: 'Search',
      add_to_cart: 'AddToShoppingCart',
      begin_checkout: 'Checkout',
      purchase: 'Off-AmazonPurchases'
    };

    if (gaToEventName[eventName]) {
      return gaToEventName[eventName];
    }

    return eventName;
  }

  return data.eventType === 'standard' ? data.eventNameStandard : data.eventNameCustom;
}

function addGDPRData(data, mappedData) {
  if (isValidValue(data.gdpr)) mappedData.gdpr = makeInteger(data.gdpr);
  if (isValidValue(data.gdprPd)) mappedData.gdpr_pd = makeInteger(data.gdprPd);
  if (data.gdprTCFConsentString) mappedData.gdpr_consent = data.gdprTCFConsentString;

  return mappedData;
}

function measurementTokenCookieToTimestampPairsArray(measurementTokenCookie) {
  if (!measurementTokenCookie) return [];
  return measurementTokenCookie.split('|').map((tokenTsPair) => {
    const parts = tokenTsPair.split('.');
    const token = parts[0];
    const timestamp = parts[1];
    return [token, makeInteger(timestamp)];
  });
}

function measurementTokenTimestampPairsArrayToCookie(measurementTokenTimestampPairs) {
  return measurementTokenTimestampPairs.map((pair) => pair.join('.')).join('|');
}

function getMeasurementTokenArray() {
  const measurementToken = getCookieValues('amznAref')[0];
  if (!measurementToken) return;
  const measurementTokenArray = measurementTokenCookieToTimestampPairsArray(measurementToken);
  return measurementTokenArray.length > 0 ? measurementTokenArray : undefined;
}

function removeAnyExpiredMeasurementTokens(data, tokens, measurementTokenTTL) {
  if (!tokens) return;

  const canSetMeasurementTokenCookie = !isUIFieldTrue(data.notSetMeasurementTokenCookie);

  const expiredTokensCutoffTimestamp = getTimestampMillis() - measurementTokenTTL;
  const unexpiredMeasurementTokens = tokens.filter(
    (pair) => pair[1] > expiredTokensCutoffTimestamp
  );

  if (canSetMeasurementTokenCookie) {
    const containsOnlyExpiredMeasurementTokens = unexpiredMeasurementTokens.length === 0;
    if (containsOnlyExpiredMeasurementTokens) {
      setCookieValue('amznAref', '', 0);
      return;
    }

    const containsOnlyUnexpiredMeasurementTokens =
      unexpiredMeasurementTokens.length === tokens.length;
    if (!containsOnlyUnexpiredMeasurementTokens) {
      const newMeasurementTokenCookie = measurementTokenTimestampPairsArrayToCookie(
        unexpiredMeasurementTokens
      );
      const newMeasurementTokenCookieExpiration = makeInteger(
        (unexpiredMeasurementTokens[0][1] + measurementTokenTTL - getTimestampMillis()) / 1000
      );
      setCookieValue('amznAref', newMeasurementTokenCookie, newMeasurementTokenCookieExpiration);
    }
  }

  return unexpiredMeasurementTokens;
}

function handleMeasurementTokenFromURL(data, tokens, measurementTokenTTL) {
  const parsedUrl = parseUrl(url);
  if (!parsedUrl || !parsedUrl.searchParams || !parsedUrl.searchParams.aref) return;

  const measurementTokenFromUrl = parsedUrl.searchParams.aref;

  const newMeasurementTokenTimestamp = getTimestampMillis();
  let updatedTokens = [[measurementTokenFromUrl, newMeasurementTokenTimestamp]].concat(
    tokens || []
  );

  const measurementTokenCookiePairsLimit = 147;
  if (updatedTokens.length >= measurementTokenCookiePairsLimit) {
    updatedTokens = updatedTokens.slice(0, measurementTokenCookiePairsLimit);
  }

  const newMeasurementTokenCookie = measurementTokenTimestampPairsArrayToCookie(updatedTokens);

  const canSetMeasurementTokenCookie = !isUIFieldTrue(data.notSetMeasurementTokenCookie);
  if (canSetMeasurementTokenCookie) {
    const newMeasurementTokenCookieExpiration = makeInteger(measurementTokenTTL / 1000);
    setCookieValue('amznAref', newMeasurementTokenCookie, newMeasurementTokenCookieExpiration);
  }

  return updatedTokens;
}

function addMeasurementToken(data, mappedData) {
  const measurementTokenTTL = 2592000000; // 30 days in milliseconds

  const existingTokens = getMeasurementTokenArray();

  const unexpiredTokens = removeAnyExpiredMeasurementTokens(
    data,
    existingTokens,
    measurementTokenTTL
  );

  if (data.tagRegion === 'NA') {
    const updatedTokens = handleMeasurementTokenFromURL(data, unexpiredTokens, measurementTokenTTL);

    if (updatedTokens)
      mappedData.arefs = measurementTokenTimestampPairsArrayToCookie(updatedTokens);
    else if (unexpiredTokens)
      mappedData.arefs = measurementTokenTimestampPairsArrayToCookie(unexpiredTokens);
  }

  return mappedData;
}

function addEventDetailsData(data, eventData, mappedData) {
  const eventParameters = {};

  if (eventData.currency) eventParameters.currencyCode = eventData.currency;

  if (isValidValue(eventData.value)) eventParameters.value = eventData.value;

  if (mappedData.event === 'Off-AmazonPurchase' && eventData.items && eventData.items[0]) {
    const unitsSold = eventData.items.reduce((acc, item) => (acc += makeInteger(item.quantity)), 0);
    if (unitsSold) eventParameters.unitsSold = unitsSold;
  }

  if (data.defaultAttributesList) {
    data.defaultAttributesList.forEach((d) => (eventParameters[d.name] = d.value));
  }

  if (mappedData.event === 'Off-AmazonPurchases' && data.offAmazonPurchasesAttributesList) {
    data.offAmazonPurchasesAttributesList.forEach((d) => (eventParameters[d.name] = d.value));
  }

  if (data.eventCustomAttributesList) {
    data.eventCustomAttributesList.forEach((d) => (eventParameters[d.name] = d.value));
  }

  mergeObj(mappedData, eventParameters);

  const matchId = data.hasOwnProperty('matchId') ? data.matchId : eventData.user_id;
  if (matchId) mappedData.MATCH_ID = matchId;

  return mappedData;
}

function getHashedRecords(data, eventData) {
  const eventDataUserData = eventData.user_data || {};
  const userData = {};

  let email =
    eventData.email ||
    eventData.email_address ||
    eventDataUserData.email ||
    eventDataUserData.email_address ||
    eventDataUserData.sha256_email_address;
  const emailType = getType(email);
  if (emailType === 'array' || emailType === 'object') email = email[0];

  let phone =
    eventData.phone ||
    eventData.phone_number ||
    eventDataUserData.phone ||
    eventDataUserData.phone_number ||
    eventDataUserData.sha256_phone_number;
  const phoneType = getType(phone);
  if (phoneType === 'array' || phoneType === 'object') phone = phone[0];

  if (email) userData.email = email;
  if (phone) userData.phonenumber = phone;

  if (data.userDataAttributesList) {
    data.userDataAttributesList.forEach((d) => {
      userData[d.name] = d.value;
    });
  }

  const hashedRecords = [];

  for (const key in userData) {
    let value = userData[key];
    if (!value) continue;

    if (key === 'phonenumber') value = normalizePhoneNumber(value);

    const hashedValue = hashData(value);
    if (!hashedValue) continue;

    hashedRecords.push({
      type: key,
      record: hashedValue
    });
  }

  return hashedRecords.length ? hashedRecords : undefined;
}

function getAmazonConsent(data, eventData) {
  const consentString = {
    geo: {},
    consent: {
      amazonConsentFormat: {}
    }
  };

  if (data.countryCode) consentString.geo.countryCode = data.countryCode;

  const ipAddress = data.hasOwnProperty('ipAddress') ? data.ipAddress : eventData.ip_override;
  if (ipAddress) consentString.geo.ipAddress = ipAddress;

  if (!data.amznAdStorage && !data.amznUserData && !data.gpp) {
    consentString.consent.amazonConsentFormat = {
      amzn_ad_storage: 'GRANTED',
      amzn_user_data: 'GRANTED'
    };
  }

  if (data.amznAdStorage) {
    consentString.consent.amazonConsentFormat.amzn_ad_storage = data.amznAdStorage;
  }
  if (data.amznUserData) {
    consentString.consent.amazonConsentFormat.amzn_user_data = data.amznUserData;
  }

  if (data.gpp) consentString.consent.gpp = data.gpp;

  return consentString;
}

function buildAIPTokenConfig(data, eventData) {
  const hashedRecords = getHashedRecords(data, eventData);
  if (!hashedRecords) return;

  const tokenConfig = {
    gdpr: 0, // 1: true, 0: false (default) - GDPR is mandatory for EU region token request.
    gdprConsent: '', // Valid IAB consent string, v1 or v2 (required if `gdpr` is 1)
    hashedRecords: hashedRecords,
    ttl: data.aipTokenCookieTTL ? makeInteger(data.aipTokenCookieTTL) : 9600 // In seconds
  };

  if (isValidValue(data.gdpr)) tokenConfig.gdpr = makeInteger(data.gdpr) === 1 ? 1 : 0;
  if (data.gdprTCFConsentString) tokenConfig.gdprConsent = data.gdprTCFConsentString;

  tokenConfig.amazonConsentString = getAmazonConsent(data, eventData);

  if (tokenConfig.gdpr && !tokenConfig.gdprConsent) {
    log({
      Name: 'Amazon',
      Type: 'Message',
      TraceId: traceId,
      EventName: 'AIP Token Request',
      Message: 'Request was not sent.',
      Reason: 'If GDPR consent is enabled, the TCFv2 consent string must be set.'
    });
    return data.gtmOnFailure();
  }

  return tokenConfig;
}

function setAIPCookie(aipTokenData) {
  setCookieValue('aatToken', aipTokenData.aipToken, aipTokenData.tokenMaxAge);
  return aipTokenData.aipToken;
}

function fetchAIPToken(data, eventData) {
  if (!isUIFieldTrue(data.enableAdvancedMatching)) {
    return Promise.create((resolve, reject) => resolve(undefined));
  }

  const existingAIPToken = getCookieValues('aatToken')[0];
  if (existingAIPToken) {
    return Promise.create((resolve, reject) => resolve(existingAIPToken));
  }

  const tokenConfig = buildAIPTokenConfig(data, eventData);
  if (!tokenConfig) {
    return Promise.create((resolve, reject) => resolve(undefined));
  }

  const requestUrl = 'https://tk.amazon-adsystem.com/envelope';
  log({
    Name: 'Amazon',
    Type: 'Request',
    TraceId: traceId,
    EventName: 'AIP Token Request',
    RequestMethod: 'POST',
    RequestUrl: requestUrl,
    RequestBody: tokenConfig
  });

  return sendHttpRequest(
    requestUrl,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    },
    JSON.stringify(tokenConfig)
  )
    .then((result) => {
      log({
        Name: 'Amazon',
        Type: 'Response',
        TraceId: traceId,
        EventName: 'AIP Token Request',
        ResponseStatusCode: result.statusCode,
        ResponseHeaders: result.headers,
        ResponseBody: result.body
      });

      if (result.statusCode >= 200 && result.statusCode < 300 && result.body) {
        let parsedBody;
        parsedBody = JSON.parse(result.body);

        if (getType(parsedBody) === 'object' && parsedBody.AIPToken) {
          setAIPCookie({
            aipToken: parsedBody.AIPToken,
            tokenMaxAge:
              makeInteger((makeInteger(parsedBody.cookieExpiry) - getTimestampMillis()) / 1000) ||
              makeInteger(data.aipTokenCookieTTL) ||
              9600
          });
          return parsedBody.AIPToken;
        }
      }
    })
    .catch((result) => {
      log({
        Name: 'Amazon',
        Type: 'Message',
        TraceId: traceId,
        EventName: 'AIP Token Request',
        Message: 'Request failed or timed out.',
        Reason: JSON.stringify(result)
      });
    });
}

function getRequestBaseUrl(data) {
  const baseUrls = {
    NA: 'https://s.amazon-adsystem.com/iu3',
    EU: 'https://aax-eu.amazon-adsystem.com/s/iu3',
    FE: 'https://aax-fe.amazon-adsystem.com/s/iu3'
  };

  return baseUrls[data.tagRegion];
}

function validateParameterName(parameter, mappedData) {
  const maxLength = 256;
  const isParameterValid = parameter.length <= maxLength;

  if (isParameterValid) return true;

  log({
    Name: 'Amazon',
    Type: 'Message',
    TraceId: traceId,
    EventName: mappedData.event,
    Message: 'Request was not sent.',
    Reason: 'Parameter "' + parameter + '" is invalid: length greater than ' + maxLength
  });

  return false;
}

function validateParameterValue(parameterValue, mappedData) {
  const maxLength = 1000;
  const isParameterValueValid = parameterValue.length <= maxLength;

  if (isParameterValueValid) return true;

  log({
    Name: 'Amazon',
    Type: 'Message',
    TraceId: traceId,
    EventName: mappedData.event,
    Message: 'Request was not sent.',
    Reason: 'Parameter value "' + parameterValue + '" is invalid: length greater than ' + maxLength
  });

  return false;
}

function getRequestUrlParameters(mappedData) {
  const requestParametersList = [];
  const reportingAttributesOnlyAlphanumericValues = [
    'brand',
    'category',
    'productid',
    'attr1',
    'attr2',
    'attr3',
    'attr4',
    'attr5',
    'attr6',
    'attr7',
    'attr8',
    'attr9',
    'attr10'
  ];
  const noValidateAttributes = ['gdpr', 'gdpr_pd', 'gdpr_consent', 'amznToken', 'arefs'];

  for (const key in mappedData) {
    let value = mappedData[key];
    if (!isValidValue(value)) continue;

    const valueType = getType(value);
    if (valueType === 'array' || valueType === 'object') value = JSON.stringify(value);
    else value = makeString(value);

    const shouldValidateAttribute = noValidateAttributes.indexOf(key) === -1;
    if (shouldValidateAttribute) {
      const isValidParameterName = validateParameterName(key, mappedData);
      if (!isValidParameterName) return null;

      let isValidParameterValue;
      if (key === 'event') {
        isValidParameterValue = validateParameterName(value, mappedData);
      } else {
        if (reportingAttributesOnlyAlphanumericValues.indexOf(key) !== -1) {
          value = replaceNonAlphanumeric(value);
        }
        isValidParameterValue = validateParameterValue(value, mappedData);
      }

      if (!isValidParameterValue) return null;
    }

    requestParametersList.push(enc(key) + '=' + enc(value));
  }

  return requestParametersList.join('&');
}

function trackEvent(mappedData, requestUrl) {
  log({
    Name: 'Amazon',
    Type: 'Request',
    TraceId: traceId,
    EventName: mappedData.event,
    RequestMethod: 'GET',
    RequestUrl: requestUrl
  });

  return sendHttpGet(requestUrl).then((result) => {
    if (result.statusCode >= 300 && result.statusCode < 400) {
      // 3rd party cookie 'ad-id' sync
      sendPixelFromBrowser(result.headers.location);
    }

    return result;
  });
}

function sendEventRequests(data, eventData, aipToken) {
  const mappedData = mapEvent(data, eventData);
  if (aipToken) mappedData.amznToken = aipToken;

  const missingParameters = areThereRequiredParametersMissing(mappedData);
  if (missingParameters) {
    log({
      Name: 'Amazon',
      Type: 'Message',
      TraceId: traceId,
      EventName: mappedData.event,
      Message: 'Request was not sent.',
      Reason: 'One or more required properties are missing: ' + missingParameters.join(' or ')
    });

    return data.gtmOnFailure();
  }

  const requestBaseUrl = getRequestBaseUrl(data);
  const requestUrlParameters = getRequestUrlParameters(mappedData);
  if (!requestUrlParameters) {
    return data.gtmOnFailure();
  }

  const eventRequests = [];
  data.tagIdsList.forEach((tagId) => {
    const tagIdValue = tagId.value;
    if (!tagIdValue) return;
    const requestUrl = requestBaseUrl + '?pid=' + tagIdValue + '&' + requestUrlParameters;
    eventRequests.push(trackEvent(mappedData, requestUrl));
  });

  Promise.all(eventRequests)
    .then((results) => {
      let someRequestFailed = false;

      results.forEach((result) => {
        log({
          Name: 'Amazon',
          Type: 'Response',
          TraceId: traceId,
          EventName: mappedData.event,
          ResponseStatusCode: result.statusCode,
          ResponseHeaders: result.headers,
          ResponseBody: result.body
        });

        if (result.statusCode < 200 || result.statusCode >= 400) {
          someRequestFailed = true;
        }
      });

      if (!useOptimisticScenario) {
        if (someRequestFailed) data.gtmOnFailure();
        else data.gtmOnSuccess();
      }
    })
    .catch((result) => {
      log({
        Name: 'Amazon',
        Type: 'Message',
        TraceId: traceId,
        EventName: mappedData.event,
        Message: 'Some request may have failed or timed out.',
        Reason: JSON.stringify(result)
      });

      if (!useOptimisticScenario) data.gtmOnFailure();
    });
}

function areThereRequiredParametersMissing(requestData) {
  const requiredParameters = ['event'];

  const anyMissing = requiredParameters.some((p) => !isValidValue(requestData[p]));
  if (anyMissing) return requiredParameters;
}

/*==============================================================================
  Helpers
==============================================================================*/

function replaceNonAlphanumeric(input) {
  if (getType(input) !== 'string') return input;

  let result = '';
  let lastWasUnderscore = false;

  for (let i = 0; i < input.length; i++) {
    const char = input.charAt(i);
    const isAlphanumeric =
      (char >= '0' && char <= '9') || (char >= 'A' && char <= 'Z') || (char >= 'a' && char <= 'z');

    if (isAlphanumeric) {
      result += char;
      lastWasUnderscore = false;
    } else if (!lastWasUnderscore) {
      result += '_';
      lastWasUnderscore = true;
    }
  }

  return result;
}

function mergeObj(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key)) target[key] = source[key];
  }
  return target;
}

function normalizePhoneNumber(phoneNumber) {
  if (!phoneNumber) return phoneNumber;
  return phoneNumber
    .split(' ')
    .join('')
    .split('-')
    .join('')
    .split('(')
    .join('')
    .split(')')
    .join('')
    .split('+')
    .join('');
}

function isHashed(value) {
  if (!value) return false;
  return makeString(value).match('^[A-Fa-f0-9]{64}$') !== null;
}

function hashData(value) {
  if (!value) return value;

  const type = getType(value);

  if (value === 'undefined' || value === 'null') return undefined;

  if (type === 'array') {
    return value.map((val) => hashData(val));
  }

  if (type === 'object') {
    return Object.keys(value).reduce((acc, val) => {
      acc[val] = hashData(value[val]);
      return acc;
    }, {});
  }

  if (isHashed(value)) return value;

  return sha256Sync(makeString(value).trim().toLowerCase(), {
    outputEncoding: 'hex'
  });
}

function isUIFieldTrue(field) {
  return [true, 'true'].indexOf(field) !== -1;
}

function isValidValue(value) {
  const valueType = getType(value);
  return valueType !== 'null' && valueType !== 'undefined' && value !== '';
}

function enc(data) {
  if (data === undefined || data === null) data = '';
  return encodeUriComponent(makeString(data));
}

function setCookieValue(name, value, maxAge) {
  const overrideCookieSettings = isUIFieldTrue(data.overrideCookieSettings);
  setCookie(name, value, {
    domain: overrideCookieSettings ? data.cookieDomain : 'auto',
    sameSite: 'strict',
    path: '/',
    secure: true,
    httpOnly: overrideCookieSettings ? !!data.cookieHttpOnly : true,
    'max-age': maxAge
  });
}

function isConsentGivenOrNotRequired() {
  if (data.adStorageConsent !== 'required') return true;
  if (eventData.consent_state) return !!eventData.consent_state.ad_storage;
  const xGaGcs = eventData['x-ga-gcs'] || ''; // x-ga-gcs is a string like "G110"
  return xGaGcs[2] === '1';
}

function log(rawDataToLog) {
  const logDestinationsHandlers = {};
  if (determinateIsLoggingEnabled()) logDestinationsHandlers.console = logConsole;
  if (determinateIsLoggingEnabledForBigQuery()) logDestinationsHandlers.bigQuery = logToBigQuery;

  const keyMappings = {
    // No transformation for Console is needed.
    bigQuery: {
      Name: 'tag_name',
      Type: 'type',
      TraceId: 'trace_id',
      EventName: 'event_name',
      RequestMethod: 'request_method',
      RequestUrl: 'request_url',
      RequestBody: 'request_body',
      ResponseStatusCode: 'response_status_code',
      ResponseHeaders: 'response_headers',
      ResponseBody: 'response_body'
    }
  };

  for (const logDestination in logDestinationsHandlers) {
    const handler = logDestinationsHandlers[logDestination];
    if (!handler) continue;

    const mapping = keyMappings[logDestination];
    const dataToLog = mapping ? {} : rawDataToLog;

    if (mapping) {
      for (const key in rawDataToLog) {
        const mappedKey = mapping[key] || key;
        dataToLog[mappedKey] = rawDataToLog[key];
      }
    }

    handler(dataToLog);
  }
}

function logConsole(dataToLog) {
  logToConsole(JSON.stringify(dataToLog));
}

function logToBigQuery(dataToLog) {
  const connectionInfo = {
    projectId: data.logBigQueryProjectId,
    datasetId: data.logBigQueryDatasetId,
    tableId: data.logBigQueryTableId
  };

  dataToLog.timestamp = getTimestampMillis();

  ['request_body', 'response_headers', 'response_body'].forEach((p) => {
    dataToLog[p] = JSON.stringify(dataToLog[p]);
  });

  const bigquery =
    getType(BigQuery) === 'function' ? BigQuery() /* Only during Unit Tests */ : BigQuery;
  bigquery.insert(connectionInfo, [dataToLog], { ignoreUnknownValues: true });
}

function determinateIsLoggingEnabled() {
  const containerVersion = getContainerVersion();
  const isDebug = !!(
    containerVersion &&
    (containerVersion.debugMode || containerVersion.previewMode)
  );

  if (!data.logType) {
    return isDebug;
  }

  if (data.logType === 'no') {
    return false;
  }

  if (data.logType === 'debug') {
    return isDebug;
  }

  return data.logType === 'always';
}

function determinateIsLoggingEnabledForBigQuery() {
  if (data.bigQueryLogType === 'no') return false;
  return data.bigQueryLogType === 'always';
}


___SERVER_PERMISSIONS___

[
  {
    "instance": {
      "key": {
        "publicId": "read_request",
        "versionId": "1"
      },
      "param": [
        {
          "key": "headerWhitelist",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "headerName"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "trace-id"
                  }
                ]
              },
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "headerName"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "referer"
                  }
                ]
              }
            ]
          }
        },
        {
          "key": "headersAllowed",
          "value": {
            "type": 8,
            "boolean": true
          }
        },
        {
          "key": "requestAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "headerAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "queryParameterAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "get_cookies",
        "versionId": "1"
      },
      "param": [
        {
          "key": "cookieAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "cookieNames",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 1,
                "string": "amznAref"
              },
              {
                "type": 1,
                "string": "aatToken"
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "logging",
        "versionId": "1"
      },
      "param": [
        {
          "key": "environments",
          "value": {
            "type": 1,
            "string": "all"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_container_data",
        "versionId": "1"
      },
      "param": []
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "set_cookies",
        "versionId": "1"
      },
      "param": [
        {
          "key": "allowedCookies",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "name"
                  },
                  {
                    "type": 1,
                    "string": "domain"
                  },
                  {
                    "type": 1,
                    "string": "path"
                  },
                  {
                    "type": 1,
                    "string": "secure"
                  },
                  {
                    "type": 1,
                    "string": "session"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "amznAref"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "any"
                  },
                  {
                    "type": 1,
                    "string": "any"
                  }
                ]
              },
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "name"
                  },
                  {
                    "type": 1,
                    "string": "domain"
                  },
                  {
                    "type": 1,
                    "string": "path"
                  },
                  {
                    "type": 1,
                    "string": "secure"
                  },
                  {
                    "type": 1,
                    "string": "session"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "aatToken"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "any"
                  },
                  {
                    "type": 1,
                    "string": "any"
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_event_data",
        "versionId": "1"
      },
      "param": [
        {
          "key": "eventDataAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "send_pixel_from_browser",
        "versionId": "1"
      },
      "param": [
        {
          "key": "allowedUrls",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "urls",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 1,
                "string": "https://s.amazon-adsystem.com/iu3*"
              },
              {
                "type": 1,
                "string": "https://aax-eu.amazon-adsystem.com/s/iu3*"
              },
              {
                "type": 1,
                "string": "https://aax-fe.amazon-adsystem.com/s/iu3*"
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "send_http",
        "versionId": "1"
      },
      "param": [
        {
          "key": "allowedUrls",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "urls",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 1,
                "string": "https://s.amazon-adsystem.com/iu3*"
              },
              {
                "type": 1,
                "string": "https://aax-eu.amazon-adsystem.com/s/iu3*"
              },
              {
                "type": 1,
                "string": "https://aax-fe.amazon-adsystem.com/s/iu3*"
              },
              {
                "type": 1,
                "string": "https://tk.amazon-adsystem.com/envelope"
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "access_bigquery",
        "versionId": "1"
      },
      "param": [
        {
          "key": "allowedTables",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "projectId"
                  },
                  {
                    "type": 1,
                    "string": "datasetId"
                  },
                  {
                    "type": 1,
                    "string": "tableId"
                  },
                  {
                    "type": 1,
                    "string": "operation"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "write"
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  }
]


___TESTS___

scenarios:
- name: '[Measurement Token] [NA Region] amznAref cookie is not set but sent in request
    if it exists (UI field true)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      notSetMeasurementTokenCookie: true,
      tagRegion: 'NA'
    });

    mock('getAllEventData', {
      page_location: 'https://example.com?aref=foobar'
    });

    const unexpiredTokens = '1111.1747945830000|2222.1747945830001';
    mock('getCookieValues', (cookieName) => {
      if (cookieName === 'amznAref') return [unexpiredTokens];
      return [];
    });

    mock('setCookie', (cookieName) => {
      if (cookieName === 'amznAref') fail('amznAref cookie should not have been set if UI field forbids it');
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.arefs).isEqualTo('foobar.1747945830456|' + unexpiredTokens);
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Measurement Token] [EU Region] amznAref cookie is not set AND not sent in
    request if it exists (UI field true)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      notSetMeasurementTokenCookie: true,
      tagRegion: 'EU'
    });

    mock('getAllEventData', {
      page_location: 'https://example.com?aref=foobar'
    });

    const unexpiredTokens = '1111.1747945830000|2222.1747945830001';
    mock('getCookieValues', (cookieName) => {
      if (cookieName === 'amznAref') return [unexpiredTokens];
      return [];
    });

    mock('setCookie', (cookieName) => {
      if (cookieName === 'amznAref') fail('amznAref cookie should not have been set if UI field forbids it');
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.arefs).isUndefined();
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Measurement Token] [EU Region] amznAref cookie is renewed with only unexpired
    tokens but not with URL parameter and is not sent in request (UI field false)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      notSetMeasurementTokenCookie: false,
      tagRegion: 'EU'
    });

    mock('getAllEventData', {
      page_location: 'https://example.com?aref=foobar'
    });

    const unexpiredTokens = '1111.1747945830000|2222.1747945830001';
    const expiredTokens = '3333.1649508781062|4444.1649506854457';

    mock('getCookieValues', (cookieName) => {
      if (cookieName === 'amznAref') return [unexpiredTokens + '|' + expiredTokens];
      return [];
    });

    mock('setCookie', (cookieName, cookieValue) => {
      if (cookieName === 'amznAref') {
        if (cookieValue === 'foobar.1747945830456' + '|' + unexpiredTokens + '|' + expiredTokens) fail('amznAref cookie should not have been updated with value form URL for EU region');
        else {
          assertThat(cookieValue).isEqualTo(unexpiredTokens);
        }
      }
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.arefs).isUndefined();
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Measurement Token] amznAref cookie is removed if it only contains expired
    tokens (UI field false)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      notSetMeasurementTokenCookie: false,
      tagRegion: 'NA'
    });

    mock('getCookieValues', (cookieName) => {
      if (cookieName === 'amznAref') return ['1111.1649508789699|2222.1649508785451|3333.1649508781062|4444.1649506854457'];
      return [];
    });

    mock('setCookie', (cookieName, cookieValue, cookieOptions) => {
      if (cookieName === 'amznAref') {
        assertThat(cookieValue).isEqualTo('');
        assertThat(cookieOptions['max-age']).isEqualTo(0);
      }
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.arefs).isUndefined();
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Measurement Token] amznAref cookie is renewed with only unexpired tokens
    (UI field false)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      notSetMeasurementTokenCookie: false,
      tagRegion: 'NA'
    });

    const unexpiredTokens = '1111.1747945830000|2222.1747945830001';
    const expiredTokens = '3333.1649508781062|4444.1649506854457';

    mock('getCookieValues', (cookieName) => {
      if (cookieName === 'amznAref') return [unexpiredTokens + '|' + expiredTokens];
      return [];
    });

    mock('setCookie', (cookieName, cookieValue, cookieOptions) => {
      if (cookieName === 'amznAref') {
        assertThat(cookieValue).isEqualTo(unexpiredTokens);
      }
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.arefs).isEqualTo(unexpiredTokens);
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Measurement Token] amznAref cookie is kept under max tokens limit (UI field
    false)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      notSetMeasurementTokenCookie: false,
      tagRegion: 'NA'
    });

    mock('getAllEventData', {
      page_location: 'https://example.com?aref=foobar'
    });

    const measurementTokenCookiePairsLimit = 147;
    const numOfTokens = measurementTokenCookiePairsLimit + 50;
    let tokens = [];
    for (let i = 0; i < numOfTokens; i++) {
      tokens.push('4444.1747945830000');
    }
    const expectedTokens = ['foobar.1747945830456'].concat(tokens).slice(0, measurementTokenCookiePairsLimit).join('|');
    tokens = tokens.join('|');

    mock('getCookieValues', (cookieName) => {
      if (cookieName === 'amznAref') return [tokens];
      return [];
    });

    mock('setCookie', (cookieName, cookieValue, cookieOptions) => {
      if (cookieName === 'amznAref') {
        assertThat(cookieValue).isEqualTo(expectedTokens);
      }
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.arefs).isEqualTo(expectedTokens);
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Measurement Token] arefs request parameter is not sent if amznAref cookie
    and URL parameter does not exist (UI field false)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      notSetMeasurementTokenCookie: true,
      tagRegion: 'EU'
    });

    mock('getAllEventData', {
      page_location: 'https://example.com'
    });

    mock('getCookieValues', (cookieName) => {
      return [];
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.arefs).isUndefined();
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Advanced Matching] aatToken request is built succesfully (UI checkbox enabled)
    - Data from UI fields'
  code: "setAllMockData({\n  tagIdsList: [\n    { value: 'tagId0' }\n  ],\n  enableAdvancedMatching:\
    \ true\n});\nsetGetAllEventData({\n  user_data: undefined\n});\n\nmock('getCookieValues',\
    \ (cookieName) => {\n  return [];\n});\n\n\nconst expectedRequestBody = {\n  gdpr:\
    \ 1,\n  gdprConsent: 'TCFv2 consent string',\n  hashedRecords: [\n    {\n    \
    \  type: 'email',\n      record: '973dfe463ec85785f5f95af5ba3906eedb2d931c24e69824a89ea65dba4e813b'\n\
    \    },\n    {\n      type: 'phonenumber',\n      record: 'be9673b570b05b32f7208280c9a7a05ea151f6b51d9d793000eed4a0cae528a7'\n\
    \    }\n  ],\n  ttl: 9600,\n  amazonConsentString: {\n    geo: {\n      countryCode:\
    \ 'BR',\n      ipAddress: '2804:14d:c096:8dd6:311c:8c00:e6c:e33'\n    },\n   \
    \ consent: {\n      amazonConsentFormat: {\n        amzn_ad_storage: 'GRANTED',\n\
    \        amzn_user_data: 'GRANTED'\n      },\n      gpp: 'Global Privacy Platform\
    \ string'\n    }\n  }\n};\nmock('sendHttpRequest', (requestUrl, requestOptions,\
    \ requestBody) => {\n  assertThat(requestUrl).isEqualTo('https://tk.amazon-adsystem.com/envelope');\n\
    \  assertThat(requestOptions).isEqualTo({\n    method: 'POST',\n    headers: {\
    \ 'Content-Type': 'application/json' }\n  });\n  assertThat(JSON.parse(requestBody)).isEqualTo(expectedRequestBody);\n\
    \  \n  return Promise.create((resolve, reject) => {\n    resolve({ statusCode:\
    \ 200, body: '{\"AIPToken\":\"tokenFromRequest\",\"cookieExpiry\":1747955430456}'\
    \ });\n  });\n});\n\nrunCode(mockData);\n\ncallLater(() => {\n  assertApi('gtmOnSuccess').wasCalled();\n\
    \  assertApi('gtmOnFailure').wasNotCalled();\n});"
- name: '[Advanced Matching] aatToken request is built succesfully (UI checkbox enabled)
    - Data from UI fields fallbacks'
  code: "setAllMockData({\n  tagIdsList: [\n    { value: 'tagId0' }\n  ],\n  enableAdvancedMatching:\
    \ true,\n  userDataAttributesList: undefined\n});\nsetGetAllEventData();\n\nmock('getCookieValues',\
    \ (cookieName) => {\n  return [];\n});\n\nconst expectedRequestBody = {\n  gdpr:\
    \ 1,\n  gdprConsent: 'TCFv2 consent string',\n  hashedRecords: [\n    {\n    \
    \  type: 'email',\n      record: '973dfe463ec85785f5f95af5ba3906eedb2d931c24e69824a89ea65dba4e813b'\n\
    \    },\n    {\n      type: 'phonenumber',\n      record: 'be9673b570b05b32f7208280c9a7a05ea151f6b51d9d793000eed4a0cae528a7'\n\
    \    }\n  ],\n  ttl: 9600,\n  amazonConsentString: {\n    geo: {\n      countryCode:\
    \ 'BR',\n      ipAddress: '2804:14d:c096:8dd6:311c:8c00:e6c:e33'\n    },\n   \
    \ consent: {\n      amazonConsentFormat: {\n        amzn_ad_storage: 'GRANTED',\n\
    \        amzn_user_data: 'GRANTED'\n      },\n      gpp: 'Global Privacy Platform\
    \ string'\n    }\n  }\n};\nmock('sendHttpRequest', (requestUrl, requestOptions,\
    \ requestBody) => {\n  assertThat(requestUrl).isEqualTo('https://tk.amazon-adsystem.com/envelope');\n\
    \  assertThat(requestOptions).isEqualTo({\n    method: 'POST',\n    headers: {\
    \ 'Content-Type': 'application/json' }\n  });\n  assertThat(JSON.parse(requestBody)).isEqualTo(expectedRequestBody);\n\
    \  \n  return Promise.create((resolve, reject) => {\n    resolve({ statusCode:\
    \ 200, body: '{\"AIPToken\":\"tokenFromRequest\",\"cookieExpiry\":1747955430456}'\
    \ });\n  });\n});\n\nrunCode(mockData);\n\ncallLater(() => {\n  assertApi('gtmOnSuccess').wasCalled();\n\
    \  assertApi('gtmOnFailure').wasNotCalled();\n});"
- name: '[Advanced Matching] aatToken is not fetched or used (UI checkbox disabled)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      enableAdvancedMatching: false
    });
    setGetAllEventData();

    mock('getCookieValues', (cookieName) => {
      if (cookieName === 'aatToken') return ['aatTokenCookie'];
      return [];
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.amznToken).isUndefined();
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    assertApi('sendHttpRequest').wasNotCalled();
    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Advanced Matching] aatToken is not fetched and is used from cookie (UI checkbox
    enabled)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      enableAdvancedMatching: true
    });
    setGetAllEventData();

    mock('getCookieValues', (cookieName) => {
      if (cookieName === 'aatToken') return ['aatTokenCookie'];
      return [];
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.amznToken).isEqualTo('aatTokenCookie');
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    assertApi('sendHttpRequest').wasNotCalled();
    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Advanced Matching] aatToken is fetched and stored in cookie if not falsy,
    if cookie does not exist (UI checkbox enabled)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      enableAdvancedMatching: true
    });
    setGetAllEventData();

    mock('getCookieValues', (cookieName) => {
      return [];
    });

    mock('setCookie', (cookieName, cookieValue, cookieOptions) => {
      if (cookieName === 'aatToken'){
        assertThat(cookieValue).isEqualTo('tokenFromRequest');
        assertThat(cookieOptions['max-age']).isEqualTo(makeInteger(mockData.aipTokenCookieTTL));
      }
    });

    mock('sendHttpRequest', (requestUrl, requestOptions, requestBody) => {
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200, body: '{"AIPToken":"tokenFromRequest","cookieExpiry":1747955430456}' });
      });
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.amznToken).isEqualTo('tokenFromRequest');
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Advanced Matching] aatToken is fetched and not stored in cookie and not
    sent if invalid, if cookie does not exist (UI checkbox enabled)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      enableAdvancedMatching: true
    });
    setGetAllEventData();

    mock('getCookieValues', (cookieName) => {
      return [];
    });

    mock('setCookie', (cookieName, cookieValue, cookieOptions) => {
      if (cookieName === 'aatToken'){
        fail('aatToken should not have been set');
      }
    });

    mock('sendHttpRequest', (requestUrl, requestOptions, requestBody) => {
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200, body: '{"AIPToken":"","cookieExpiry":1747955430456}' });
      });
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.amznToken).isUndefined();
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Advanced Matching] Event request is sent even when Advanced Matching Request
    fails (UI checkbox enabled)'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      enableAdvancedMatching: true
    });
    setGetAllEventData();

    mock('getCookieValues', (cookieName) => {
      return [];
    });

    mock('sendHttpRequest', (requestUrl, requestOptions, requestBody) => {
      return Promise.create((resolve, reject) => {
        reject({ reason: 'Reason rejected'});
      });
    });

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl).searchParams;
      assertThat(parsedRequestUrl.amznToken).isUndefined();
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Event] Event request is NOT sent when required fields are missing'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      eventType: 'standard',
      eventNameStandard: undefined
    });

    runCode(mockData);

    assertApi('sendHttpGet').wasNotCalled();

    callLater(() => {
      assertApi('gtmOnSuccess').wasNotCalled();
      assertApi('gtmOnFailure').wasCalled();
    });
- name: '[Event] Event request base URL is correct based on Tag Region'
  code: "setAllMockData({\n  tagIdsList: [\n    { value: 'tagId0' }\n  ],\n  tagRegion:\
    \ 'NA',\n  eventType: 'standard',\n  eventNameStandard: 'Off-AmazonPurchases',\n\
    });\n\nconst expectedRequestBaseUrl = {\n  NA: 'https://s.amazon-adsystem.com/iu3',\n\
    \  EU: 'https://aax-eu.amazon-adsystem.com/s/iu3'\n};\n\n['NA', 'EU'].forEach(tagRegion\
    \ => {\n  const originalMockDataCopy = JSON.parse(JSON.stringify(mockData));\n\
    \  \n  originalMockDataCopy.tagRegion = tagRegion;\n  \n  mock('sendHttpGet',\
    \ (requestUrl) => {\n    const parsedRequestUrl = parseUrl(requestUrl);\n    const\
    \ requestBaseUrl = parsedRequestUrl.origin + parsedRequestUrl.pathname;\n    assertThat(requestBaseUrl).isEqualTo(expectedRequestBaseUrl[tagRegion]);\n\
    \    return Promise.create((resolve, reject) => {\n      resolve({ statusCode:\
    \ 200 });\n    });\n  });\n  \n  runCode(originalMockDataCopy);\n  \n  callLater(()\
    \ => {\n    assertApi('gtmOnSuccess').wasCalled();\n    assertApi('gtmOnFailure').wasNotCalled();\n\
    \  });\n});"
- name: '[Event] Event request is successfully built and sent - Data from UI fields'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      tagRegion: 'NA',
      eventType: 'standard',
      eventNameStandard: 'Off-AmazonPurchases',
    });

    const expectedRequestHostname = 'https://s.amazon-adsystem.com/iu3';
    const expectedRequestParameters = {
      pid: 'tagId0',
      event: 'Off-AmazonPurchases',
      eventSource: 'gtm-server-side',
      ts: '1747945830456',
      gdpr: '1',
      gdpr_pd: '1',
      gdpr_consent: 'TCFv2 consent string',
      brand: 'brand',
      category: 'category',
      foo: 'bar',
      MATCH_ID: 'userId',
      currencyCode: 'currencyCode'
    };

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl);
      const requestBaseUrl = parsedRequestUrl.origin + parsedRequestUrl.pathname;
      const requestParameters = parsedRequestUrl.searchParams;
      assertThat(requestBaseUrl).isEqualTo(expectedRequestHostname);
      assertThat(requestParameters).isEqualTo(expectedRequestParameters);
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Event] Event request is successfully built and sent - Data from UI fields
    fallbacks'
  code: |-
    setGetAllEventData({});

    const expectedRequestHostname = 'https://s.amazon-adsystem.com/iu3';
    const expectedRequestParameters = {
      pid: 'tagId0',
      event: 'Off-AmazonPurchases',
      eventSource: 'gtm-server-side',
      ts: '1747945830456',
      MATCH_ID: 'userId',
      currencyCode: 'BRL',
      value: '123.45'
    };

    mock('sendHttpGet', (requestUrl) => {
      const parsedRequestUrl = parseUrl(requestUrl);
      const requestBaseUrl = parsedRequestUrl.origin + parsedRequestUrl.pathname;
      const requestParameters = parsedRequestUrl.searchParams;
      const l = require('logToConsole');
      l(parsedRequestUrl);
      assertThat(requestBaseUrl).isEqualTo(expectedRequestHostname);
      assertThat(requestParameters).isEqualTo(expectedRequestParameters);
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200 });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: '[Event] Event request is successfully built and sent for multiple Tag IDs'
  code: "setAllMockData({\n  tagIdsList: [\n    { value: 'tagId0' },\n    { value:\
    \ 'tagId1' }\n  ],\n  tagRegion: 'NA',\n  eventType: 'standard',\n  eventNameStandard:\
    \ 'Off-AmazonPurchases',\n});\n\nconst expectedRequestParameters = {\n  event:\
    \ 'Off-AmazonPurchases',\n  eventSource: 'gtm-server-side',\n  ts: '1747945830456',\n\
    \  gdpr: '1',\n  gdpr_pd: '1',\n  gdpr_consent: 'TCFv2 consent string',\n  brand:\
    \ 'brand',\n  category: 'category',\n  foo: 'bar',\n  MATCH_ID: 'userId',\n  currencyCode:\
    \ 'currencyCode'\n};\n\nconst tagIds = ['tagId0', 'tagId1'];\nlet sendHttpGetExecutions\
    \ = 0;\nmock('sendHttpGet', (requestUrl) => {\n  const parsedRequestUrl = parseUrl(requestUrl);\n\
    \  const requestParameters = parsedRequestUrl.searchParams;\n  assertThat(requestParameters.pid).isEqualTo(tagIds[sendHttpGetExecutions]);\n\
    \  \n  sendHttpGetExecutions++;\n  \n  return Promise.create((resolve, reject)\
    \ => {\n    resolve({ statusCode: 200 });\n  });\n});\n\nrunCode(mockData);\n\n\
    callLater(() => {\n  assertApi('gtmOnSuccess').wasCalled();\n  assertApi('gtmOnFailure').wasNotCalled();\n\
    });"
- name: '[Event] sendPixelFromBrowser is called when the Event request produces a
    30X redirect'
  code: |-
    setAllMockData({
      tagIdsList: [
        { value: 'tagId0' }
      ],
      tagRegion: 'NA',
      eventType: 'standard',
      eventNameStandard: 'Off-AmazonPurchases',
    });

    const sendPixelFromBrowserUrl = 'https://s.amazon-adsystem.com/iu3?pid=tagId0&event=Off-AmazonPurchases&eventSource=gtm-server-side&ts=1747945830456&gdpr=1&gdpr_pd=1&gdpr_consent=TCFv2%20consent%20string&brand=brand&category=category&foo=bar&MATCH_ID=userId';
    mock('sendHttpGet', (requestUrl) => {
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 302, headers: { location: sendPixelFromBrowserUrl } });
      });
    });

    runCode(mockData);

    callLater(() => {
      assertApi('sendPixelFromBrowser').wasCalledWith(sendPixelFromBrowserUrl);
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: Should log to console, if the 'Always log to console' option is selected
  code: "setAllMockData({\n  logType: 'always'\n});\n\nconst expectedDebugMode = true;\n\
    mock('getContainerVersion', () => {\n  return {\n    debugMode: expectedDebugMode\n\
    \  };\n}); \n\nmock('logToConsole', (logData) => {\n  const parsedLogData = JSON.parse(logData);\n\
    \  requiredConsoleKeys.forEach(p => assertThat(parsedLogData[p]).isDefined());\n\
    });\n\nrunCode(mockData);\n\ncallLater(() => {\n  assertApi('logToConsole').wasCalled();\n\
    \  assertApi('gtmOnSuccess').wasCalled();\n  assertApi('gtmOnFailure').wasNotCalled();\n\
    });"
- name: Should log to console, if the 'Log during debug and preview' option is selected
    AND is on preview mode
  code: |-
    setAllMockData({
      logType: 'debug'
    });

    const expectedDebugMode = true;
    mock('getContainerVersion', () => {
      return {
        debugMode: expectedDebugMode
      };
    });

    mock('logToConsole', (logData) => {
      const parsedLogData = JSON.parse(logData);
      requiredConsoleKeys.forEach(p => assertThat(parsedLogData[p]).isDefined());
    });


    runCode(mockData);

    callLater(() => {
      assertApi('logToConsole').wasCalled();
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: Should NOT log to console, if the 'Log during debug and preview' option is
    selected AND is NOT on preview mode
  code: "setAllMockData({\n  logType: 'debug'\n});\n\nconst expectedDebugMode = false;\n\
    mock('getContainerVersion', () => {\n  return {\n    debugMode: expectedDebugMode\n\
    \  };\n}); \n\nrunCode(mockData);\n\ncallLater(() => {\n  assertApi('logToConsole').wasNotCalled();\n\
    \  assertApi('gtmOnSuccess').wasCalled();\n  assertApi('gtmOnFailure').wasNotCalled();\n\
    });"
- name: Should NOT log to console, if the 'Do not log' option is selected
  code: |-
    setAllMockData({
      logType: 'no'
    });

    runCode(mockData);

    callLater(() => {
      assertApi('logToConsole').wasNotCalled();
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: Should log to BQ, if the 'Log to BigQuery' option is selected
  code: "setAllMockData({\n  bigQueryLogType: 'always'\n});\n\n// assertApi doesn't\
    \ work for 'BigQuery.insert()'.\n// Ref: https://gtm-gear.com/posts/gtm-templates-testing/\n\
    mock('BigQuery', () => {\n  return { \n    insert: (connectionInfo, rows, options)\
    \ => { \n      assertThat(connectionInfo).isDefined();\n      assertThat(rows).isArray();\n\
    \      assertThat(rows).hasLength(1);\n      requiredBqKeys.forEach(p => assertThat(rows[0][p]).isDefined());\n\
    \      assertThat(options).isEqualTo(expectedBqOptions);\n      return Promise.create((resolve,\
    \ reject) => {\n        resolve();\n      });\n    }\n  };\n});\n\nrunCode(mockData);\n\
    \ncallLater(() => {\n  assertApi('gtmOnSuccess').wasCalled();\n  assertApi('gtmOnFailure').wasNotCalled();\n\
    });"
- name: Should NOT log to BQ, if the 'Do not log to BigQuery' option is selected
  code: "setAllMockData({\n  bigQueryLogType: 'no'\n});\n\n// assertApi doesn't work\
    \ for 'BigQuery.insert()'.\n// Ref: https://gtm-gear.com/posts/gtm-templates-testing/\n\
    mock('BigQuery', () => {\n  return { \n    insert: (connectionInfo, rows, options)\
    \ => { \n      fail('BigQuery.insert should not have been called.');\n      return\
    \ Promise.create((resolve, reject) => {\n        resolve();\n      });\n    }\n\
    \  };\n});\n\nrunCode(mockData);\n\ncallLater(() => {\n  assertApi('gtmOnSuccess').wasCalled();\n\
    \  assertApi('gtmOnFailure').wasNotCalled();\n});"
setup: "const JSON = require('JSON');\nconst Promise = require('Promise');\nconst\
  \ parseUrl = require('parseUrl');\nconst makeInteger = require('makeInteger');\n\
  const callLater = require('callLater');\n\nconst mergeObj = (target, source) =>\
  \ {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) target[key]\
  \ = source[key];\n  }\n  return target;\n};\n\nconst setGetAllEventData = (objToBeMerged)\
  \ => {\n  mock('getAllEventData', mergeObj({\n    'x-ga-protocol_version': '2',\n\
  \    'x-ga-measurement_id': 'G-123ABC',\n    'x-ga-gtm_version': '45je55e1za200',\n\
  \    'x-ga-page_id': 1747422523211,\n    'x-ga-gcd': '13l3l3l3l1l1',\n    'x-ga-npa':\
  \ '0',\n    'x-ga-dma': '0',\n    'x-ga-mp2-tag_exp':\n      '101509157~103116025~103130498~103130500~103136993~103136995~103200001~103207802~103211513~103233427~103252644~103252646~103263073~103301114~103301116',\n\
  \    client_id: 'AUJctU7H7hBB/aMuhE4pKwGu5DWDdklg5abyyyn8i/I=.1747154479',\n   \
  \ 'x-ga-ecid': '1294673677',\n    language: 'en-us',\n    screen_resolution: '1512x982',\n\
  \    event_location: { country: 'BR', region: 'SP' },\n    event_id: '101509157~103116025~103130498',\n\
  \    timestamp: 1748377016,\n    client_hints: {\n      architecture: 'arm',\n \
  \     bitness: '64',\n      full_version_list: [\n        { brand: 'Chromium', version:\
  \ '136.0.7103.93' },\n        { brand: 'Google Chrome', version: '136.0.7103.93'\
  \ },\n        { brand: 'Not.A/Brand', version: '99.0.0.0' }\n      ],\n      mobile:\
  \ false,\n      model: '',\n      platform: 'macOS',\n      platform_version: '15.2.0',\n\
  \      wow64: false,\n      brands: [\n        { brand: 'Chromium', version: '136'\
  \ },\n        { brand: 'Google Chrome', version: '136' },\n        { brand: 'Not.A/Brand',\
  \ version: '99' }\n      ]\n    },\n    'x-ga-are': '1',\n    'x-ga-mp2-frm': '0',\n\
  \    'x-ga-pscdl': 'noapi',\n    'x-ga-system_properties': { eu: [34], tu: 'BA',\
  \ ss: '1', ee: true },\n    'x-sst-system_properties': {\n      etld: 'google.com.br',\n\
  \      tft: '1747422523211',\n      lpc: '60493049',\n      navt: 'r',\n      ude:\
  \ '0',\n      sw_exp: '1',\n      request_start_time_ms: 1747422524851\n    },\n\
  \    'x-ga-request_count': 1,\n    ga_session_id: '1747422523',\n    ga_session_number:\
  \ 3,\n    'x-ga-mp2-seg': '0',\n    page_location: 'https://example.com/?test=1i23i21j3',\n\
  \    page_title: 'Example Domain',\n    event_name: 'page_view',\n    'x-ga-tfd':\
  \ 5784,\n    ip_override: '2804:14d:c096:8dd6:311c:8c00:e6c:e33',\n    user_agent:\n\
  \      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML,\
  \ like Gecko) Chrome/136.0.0.0 Safari/537.36',\n    value: 123.45,\n    currency:\
  \ 'BRL',\n    user_id: 'userId',\n    user_data: {\n      email: { 0: 'test@example.com',\
  \ 1: 'test2@example.net' },\n      phone_number: '+55 19 9-9999-9999'\n    },\n\
  \    coupon: 'coupon',\n    items: [\n      {\n        item_id: 'SKU_12345',\n \
  \       item_name: 'Stan and Friends Tee',\n        affiliation: 'Google Merchandise\
  \ Store',\n        coupon: 'SUMMER_FUN',\n        discount: 2.22,\n        index:\
  \ 0,\n        item_brand: 'Google',\n        item_category: 'Apparel|iajsdiajsd|oasodiasd',\n\
  \        item_list_id: 'related_products',\n        item_list_name: 'Related Products',\n\
  \        item_variant: 'green',\n        location_id: 'ChIJIQBpAG2ahYAR_6128GcTUEo',\n\
  \        price: 10.01,\n        quantity: 3\n      },\n      {\n        item_id:\
  \ 'SKU_12346',\n        item_name: \"Google Grey Women's (Tee)\",\n        affiliation:\
  \ 'Google Merchandise Store',\n        coupon: 'SUMMER_FUN',\n        discount:\
  \ 3.33,\n        index: 1,\n        item_brand: 'Google',\n        item_category:\
  \ 'Apparel|iajsdiajsd|oasodiasd',\n        item_list_id: 'related_products',\n \
  \       item_list_name: 'Related Products',\n        item_variant: 'gray',\n   \
  \     location_id: 'ChIJIQBpAG2ahYAR_6128GcTUEo',\n        price: 21.01,\n     \
  \   promotion_id: 'P_12345',\n        promotion_name: 'Summer Sale',\n        quantity:\
  \ 2\n      }\n    ]\n  }, objToBeMerged || {}));\n};\n\nconst expectedBigQuerySettings\
  \ = {\n  logBigQueryProjectId: 'logBigQueryProjectId',\n  logBigQueryDatasetId:\
  \ 'logBigQueryDatasetId',\n  logBigQueryTableId: 'logBigQueryTableId'\n};\n\nconst\
  \ requiredConsoleKeys = ['Type', 'TraceId', 'Name'];\nconst requiredBqKeys = ['timestamp',\
  \ 'type', 'trace_id', 'tag_name'];\nconst expectedBqOptions = { ignoreUnknownValues:\
  \ true };\n\nconst mockData = {\n  eventType: 'standard',\n  eventNameStandard:\
  \ 'Off-AmazonPurchases',\n  tagIdsList: [\n    { value: 'tagId0' }\n  ],\n  tagRegion:\
  \ 'NA',\n  notSetMeasurementTokenCookie: false,\n  overrideCookieSettings: false,\n\
  \  useOptimisticScenario: false,\n  logBigQueryProjectId: expectedBigQuerySettings.logBigQueryProjectId,\n\
  \  logBigQueryDatasetId: expectedBigQuerySettings.logBigQueryDatasetId,\n  logBigQueryTableId:\
  \ expectedBigQuerySettings.logBigQueryTableId\n};\n\nconst setAllMockData = (objToBeMerged)\
  \ => {  \n  mergeObj(mockData, \n    mergeObj({\n      enableAdvancedMatching: true,\n\
  \      matchId: 'userId',\n      userDataAttributesList: [\n        { name: 'email',\
  \ value: 'test@example.com' },\n        { name: 'phonenumber', value: '+55 19 9-9999-9999'\
  \ }\n      ],\n      aipTokenCookieTTL: '9600',\n      countryCode: 'BR',\n    \
  \  ipAddress: '2804:14d:c096:8dd6:311c:8c00:e6c:e33',\n      amznUserData: 'GRANTED',\n\
  \      amznAdStorage: 'GRANTED',\n      gpp: 'Global Privacy Platform string',\n\
  \    \n      includeTCFv2: true,\n      gdpr: 1,\n      gdprPd: 1,\n      gdprTCFConsentString:\
  \ 'TCFv2 consent string',\n        \n      defaultAttributesList: [\n        { name:\
  \ 'brand', value: 'brand' },\n        { name: 'category', value: 'category' }\n\
  \      ],\n      offAmazonPurchasesAttributesList: [\n        { name: 'currencyCode',\
  \ value: 'currencyCode' }\n      ],\n      eventCustomAttributesList: [{ name: 'foo',\
  \ value: 'bar' }],\n      \n      adStorageConsent: 'optional',\n      logType:\
  \ 'debug',\n      bigQueryLogType: 'no'\n    }, objToBeMerged || {})\n  );\n};\n\
  \n\nmock('getRequestHeader', (header) => {\n  if (header === 'trace-id') return\
  \ 'expectedTraceId';\n});\n\nmock('getTimestampMillis', 1747945830456);\n\nmock('sendHttpRequest',\
  \ (requestUrl, requestOptions, requestBody) => {\n  return Promise.create((resolve,\
  \ reject) => {\n    resolve({ statusCode: 200 });\n  });\n});\n\nmock('sendHttpGet',\
  \ (requestUrl) => {\n  return Promise.create((resolve, reject) => {\n    resolve({\
  \ statusCode: 200 });\n  });\n});"


___NOTES___

Created on 6/11/2025, 12:20:30 PM

